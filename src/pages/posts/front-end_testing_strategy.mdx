---
title: "[번역] 프론트엔드 테스팅 전략"
description: "Kent C. Dodds의 원칙을 기반으로 하는 프론트엔드 테스트 전략을 소개합니다."
keywords: "조성동,doong-jo,프론트엔드,개발,개발 블로그,기술 블로그,frontend,tech,blog,developer,javascript,css,html,typescript,react,테스팅,테스트,테스트 방법,테스트 전략,testing,testing strategy"
author: "doong-jo"
date: "2022-04-27"
image: "https://doong-jo.github.io/og/front-end_testing.png"
url: "https://doong-jo.github.io/posts/front-end_testing_strategy"
---

# 프론트엔드 테스팅 전략

> 원문: https://itnext.io/front-end-testing-strategy-5fddfd463feb

> 트레이드오프: 트레이드오프(trade-off, tradeoff) 또는 상충 관계는 다른 측면에서 이득을 얻으면서 ... 잃어버리는 일이 수반되는 상황적 결정이다. 즉, 하나가 증가하면 다른 하나는 무조건 감소한다는 것을 뜻한다. ([위키백과](https://ko.wikipedia.org/wiki/%ED%8A%B8%EB%A0%88%EC%9D%B4%EB%93%9C%EC%98%A4%ED%94%84))
>
> Mock: 모의 객체(Mock Object)란 주로 ... 실제 사용하는 모듈을 사용하지 않고 실제의 모듈을 "흉내"내는 "가짜" 모듈을 작성하여 테스트의 효용성을 높이는데 사용하는 객체이다. ([위키백과](https://ko.wikipedia.org/wiki/%EB%AA%A8%EC%9D%98_%EA%B0%9D%EC%B2%B4))
>
> human error: 사람의 실수로 만들어지는 오류 ([위키백과](https://en.wikipedia.org/wiki/Human_error))

다양한 테스트 레이어를 정의하고 현재 상황을 짚어보며 효과적인 전략에 대해 제안합니다.

![image1.png](https://miro.medium.com/max/1400/1*PXPDiNKxOAbIR9MtwqQXZg.png)

앞서 이 글에서 중점으로 보는 부분은 아래와 같습니다.

- 프론트엔드 테스팅만을 중점적으로 합니다 (예: 리액트 어플리케션과 컴포넌트와의 상호작용).
- 많은 부분을 [Kent C. Dodds](https://medium.com/u/db72389e89d8?source=post_page-----5fddfd463feb--------------------------------)의 테스팅 원칙을 기반으로 합니다. 그는 리액트 생태계에서 가장 유명한 개발자 중 한명이며 여러 오픈소스 라이브러리(https://testing-library.com/)를 만들었고 뿐만 아니라 높은 퀄리티의 교육과정들과 글을 배포하고 있습니다.

## I) 소개

### 1. 우리는 왜 테스트를 작성해야하는가?

테스트는 작업하는 흐름의 속도를 높이고 코드 품질을 개선하는 데 도움이 될 수 있지만 테스트를 작성하는 가장 크고 중요한 이유는 **자신감**입니다.
여러분이 작성하는 코드가 미래를 대비하면서 앱을 망가뜨리지 않을 것이라는 확신을 원합니다.
따라서 무엇을 하던지, 여러분은 작성하는 여러 종류의 테스트들이 가능한 한 큰 자신감을 복돋아 줄 수 있게 만들고 싶겠지만 테스팅할 때 만들어지는 트레이드 오프의 대해 인지하는 것도 필요합니다.

---

**Resources:**

- [Kent C. Dodds — Confidently Shipping Code](https://kentcdodds.com/blog/confidently-shipping-code)
- [Kent C. Dodds — How to know what to test?](https://kentcdodds.com/blog/how-to-know-what-to-test)

---

### 2. Types of test

> 당신은 벽에 페인트를 던져 많은 부분의 벽을 칠할 수 있겠지만 브러시를 들고 벽에 오르지 않으면 모서리는 절대 칠하지 못할 것입니다. 🖌️

이 은유는 테스팅에 관한 내용에도 딱 맞게 적용됩니다. 왜냐하면 기본적으로 여러분이 세울 테스팅 전략을 올바르게 선택하는 것이 벽을 칠할 브러시를 선택할 때와 동일선상에 있기 때문입니다.
수동 테스팅은 레이어 중 하나입니다. 자동화 테스팅에 대해 이야기 할때는 단위 테스트, 통합 테스트, 종단 간 테스트 (E2E)과 같은 가장 일반적인 것들에 대해 알아봅니다.
그리고나서 (예를 들어 자바와 같은 다른 어어와 달리)자바스크립트에서는 기본적으로 type이 없으므로 일반적인 정적 도구 툴을 포함합니다(Typescript, Flow, ESLint, …).

![image1](https://miro.medium.com/max/1400/1*iBBcTAf4zvn7yZq4K4MShA.png)

#### 정적 테스트

정적 테스트는 요구되는 실행 가능한 코드없이 수행 가능합니다. 설정이 쉽고 빠르며 어플리에키션을 개발하는 동안 오타 및 타입 에러를 지속적으로 포착할 수 있습니다.
TypeScript(Typing programming language) 및 ESLint(Linters)는 이러한 유형의 테스트를 수행하는 일반적인 도구입니다.

#### 단위 테스트

단위 테스트는 소프트웨어의 작고 독립적인 부분들(또는 원자단위)이 예상대로 작동하는지 확인합니다. 일반적으로 종속성(공동 작업자)이 없거나 테스트를 위해 mocked된 것들에 대해 테스트 합니다.
`Jest`는 해당 유형의 테스트를 수행하는 공통 도구입니다.

#### 통합 테스트

통합 테스트는 여러 단위(기능, 구성 요소, 클래스 등)의 조합으로 함께 의도한대로 작동하는지 확인합니다. 행동을 전체적으로 테스트하고 가능한 한 적게 mock 하려고합니다. 통합 테스트는 다른 것들과 독립적인 하나의 시스템(예: 프론트엔드)을 다루고 있습니다.

`Jest` 는 이 유형을 테스트 하는데 가장 일반적으로 사용되는 도구입니다.

> "단위 란 무엇인가? vs "통합은 무엇입니까?" 코드를 보는 관점에 따라 다릅니다.
>
> 하나의 드롭다운이 있는 컴포넌트 라이브러리를 사용하는 어플리케이션 예로 들어봅시다.
>
> - 컴포넌트 라이브러리 관점: Dropdown의 내부의 함수는 단위이며 Dropwodn 전체는 통합입니다.
> - 어플리케이션 관점: Dropdown은 단위가 됩니다. 페이지의 Form은 통합입니다.

#### 종단 간 테스트 (E2E)

E2E 테스트(어떤 때는 "함수형 테스팅" 이라고 불리기도 하는) 모든 시스템(Front-end, Back-end, …)을 포함하여 테스트합니다.
브라우저를 자동화하고 어플리케이션를 통틀어 정형화한 사용자 흐름을 재현하려고합니다. (어플리케이션을 로드하고, 로그인 단계를 거쳐, 페이지와 상호작용, …).
E2E는 여러분의 소프트웨어의 큰 부분을 보장할 수 있도록 도와줍니다.

`Cypress`는 이 유형을 테스트 하는데 가장 일반적으로 사용되는 도구입니다.

#### 수동 테스트

수동 테스트는 자동화 된 도구를 사용하지 않고 수행되는 테스트를 제안합니다.

사람이 사용자가 어떤 것을 하는지 정확히 재현합니다.

예시)

1. 컴퓨터에 앞에 앉는다.
2. 브라우저로 어플리케이션을 연다.
3. 로그인을 한다.
4. 어딘가를 누른다.

목표는 개발자가 예상하지 못하거나 자동화된 도구에서 감지하지 못한 버그를 잡는 것입니다.

---

**Resources:**

- [Kent C. Dodds — What We Can Learn About Testing From The Wheel](https://youtu.be/Da9wfQ0frGA)
- [Kent C. Dodds — The Testing Trophy and Testing Classifications](https://kentcdodds.com/blog/the-testing-trophy-and-testing-classifications)
- [Kent C. Dodds — Static vs Unit vs Integration vs E2E Testing for Frontend Apps](https://kentcdodds.com/blog/static-vs-unit-vs-integration-vs-e2e-tests)

---

### 3. 어떤 테스트가 가장 큰 자신감을 주는가?

![image2](https://miro.medium.com/max/1194/1*3OXQSU4sjlSO_tCPLYTGkA.png)

> 테스트가 소프트웨어 사용 방식과 유사할수록 더 많은 자신감을 줄 수 있습니다.

테스트를 통해 여러분은 여러분의 소프트웨어가 릴리즈 하였을 때 의도한대로 동작하고 있는지 확인하려 합니다. 이렇게 하려면 최선의 방법은 소프트웨어에 대한 최종 사용자의 관점을 염두에 두고 테스트를 작성하는 것입니다.
간단한 원칙에 따라 수동 테스트는 최종 사용자가 어플리케이션과 상호작용 하는 것과 가장 유사하기 때문에 최선의 선택지처럼 보입니다. 그러나 소프트웨어를 테스트할 때 규모에 유연한 해결책이 아닙니다.

여러분은 소프트웨어에서 만든 어떠한 변경사항도, 개발환경에서 프로덕션에 배포하기 전에는 아무것도 깨지지 않길 바라겠지만 만약 이것들을 수동 테스트를 한다면 굉장히 오래걸릴겁니다. 덧붙여서 수동 테스트는 많은 human error를 만들게 합니다.
그렇기 때문에 대안인 더 빠르고, 확장가능하며, human error로 부터 해방되는 자동화 테스트를 선호하는 것입니다. (잘 작성된 경우)

---

**Resources:**

- [Testing Library — Guiding Principles](https://testing-library.com/docs/guiding-principles/)

---

## II) 트레이드 오프에 대해서 이야기 해봅시다.

### 1. Code coverage

![image3](https://miro.medium.com/max/1006/1*-cKATYalSQgYDNrA6rOfGg.png)

어플리케이션에 대한 100% 코드 커버리지를 의무화하는 것은 좋은 생각이 아닙니다. 코드 커버리지가 특정 숫자를 넘어 증가할 때 테스트로부터 받는 이득이 적어지게 됩니다. (70%로 가정해봅시다)
You get diminishing returns on your tests when the coverage increases beyond a certain number (Let’s say 70% for example).
먄약 애써 많은 시간을 100%를 위해 쓴다면, 여러분은 테스트가 필요하지 않은 것들을 테스팅하는데 많은 시간을 보내고 있는 여러분 자신을 발견하게 됩니다.

테스트가 필요하지 않은 것들:

- **전혀 로직이 없는 것들**: 어떤 버그도 ESLint나 Typescript에 의해 발견될 수 있습니다.
- **구현 세부 사항**: 구현 세부사항은 여러분의 소프트웨어가 잘 동작하고 있을 때 매우 큰 자신감은 주지 않습니다. 그리고 이건 여러분을 리팩토링할 때 느리게 만듭니다(여러분은 동작이 동일하게 유지되므로 코드를 리팩토링 할 때 매우 드문 경우에 테스트를 변경해야할 것입니다).
  이것은 아래 사항으로 도달하게 합니다.
  - 거짓 음성: 어플리케이션 코드를 리팩토링할 때 깨질 수 있습니다.
  - 거짓 양성: 어플리케이션 코드가 깨져도 실패하지 않을 수 있습니다.

> 거짓 음성: 스팸 메일이 아닌데 스팸 메일이라고 하는 것
> 거짓 양성: 스팸 메일인데 스팸 메일이 아니라고 하는 것
> [위키백과](https://ko.wikipedia.org/wiki/%EA%B1%B0%EC%A7%93_%EC%96%91%EC%84%B1%EA%B3%BC_%EA%B1%B0%EC%A7%93_%EC%9D%8C%EC%84%B1)

> **구현 세부 사항을 어떻게 결정하나요?**

> 여러분의 테스트가 실제 코드가 사용되지 않는 경우에 대해 무엇인가를 한다면 그것은 세부 구현사항을 테스팅 하는 것 입니다(예를 들면 은닉된 함수를 노출시키는 것).

#### Commons coverage에 대한 오해

Code coverage가 여러분에게 말하는 것:

- 이 테스트가 실행될 때 이 코드 라인이 실행되었습니다.

Code coverage가 여러분에게 말하지 않는 것:

- 코드의 이 부분은 비즈니스 요구 사항에 따라 작동합니다.
- 코드의 이 부분은 어플리케이션의 다른 모든 코드들과 잘 작동합니다.
- 코드의 이 부분은 다른 부분보다 테스트하는 것이 더 중요합니다.

#### Code Coverage < Use Case Coverage

You should concern less about the code you are testing and more about the use cases that code supports because :

- Code changes more often than use cases do
- The code can be “working” when the use case is broken

---

**Resources:**

- [Kent C. Dodds — Common Testing Mistakes](https://kentcdodds.com/blog/common-testing-mistakes#mistake-number-2-100-codecoverage)
- [Aaron Abramov — Establishing testing patterns with software design principles](https://youtu.be/_pnW-JjmyXE)
- [Kent C. Dodds — Testing Implementation Details](https://kentcdodds.com/blog/testing-implementation-details)
- [Kent C. Dodds — Avoid the Test User](https://kentcdodds.com/blog/avoid-the-test-user)
- [Kent C. Dodds — How to know what to test?](https://kentcdodds.com/blog/how-to-know-what-to-test#code-coverage--use-case-coverage)

---

### 2. How to know what to test?

Since you won’t be able to test everything, you will have to decide where you want to focus your effort.

#### Testing pyramid

You may already know the Testing pyramid, which is a popular way to talk about the different layers of testing. The following one is a combination of [Martin Fowler’s blog](https://martinfowler.com/bliki/TestPyramid.html) and one from the [Google Testing blog](https://testing.googleblog.com/2015/04/just-say-no-to-more-end-to-end-tests.html) :

![image4](https://miro.medium.com/max/1400/1*MwuGw31HDIM_q70NsPkcuQ.png)

The size of these forms of testing on the pyramid is relative to the amount of focus you should give them when testing your applications.

Both arrows indicate the trade-off you are making when you move through the pyramid. As you move up the pyramid, the tests get slower to write/run and more expensive (in terms of time and resources) to run/maintain. When you go up, your tests tend to become also more finicky and there are more points to failure.

Following only those two aspects, It’s meant to indicate that you should spend more of your time on unit tests because they are at the same time cheap and fast.

But there are a few problems here :

1 — This pyramid was created in 2012 and based on this assumption (provides from the bottom notes of Martin Fowler’s blog) :

![image5](https://miro.medium.com/max/1400/1*PcjJ62vDPGPJaMtgVHbv_g.png)

Which is less true now. The testing tools are much better in comparison to what they were before (Better in terms of performance, but also to be able to tell what part of the test has caused the failure as well as describe the problem).

2 — The pyramid was created at a time when the front-end testing ecosystem wasn’t as great as it is now. A decade ago, our tools were not well-equipped for reproducing the front-end end-user.
Most of the tests, tools, and the pyramid were back-end focused. And the reason is that the back-end is “easier” to test in comparison to testing the front-end. They build software which talks directly to other software (Which can be considered as their users). So it’s natural for them to write tests that would look like the code they want to test.
For the front-end, the users could be the end-users, who have fingers, hands and will click around, type some stuff on the keyboard, potentially use some screen readers, etc. It’s a lot more complicated to reproduce their behavior. Fortunately, a lot of things have changed in these recent years, and we have now better tools (Ex: Testing Library) to be able to test our software in the same way that the user would do.

3 — The pyramid does not address Static testing. It’s because it was defined for developers who are using static type languages (Ex: Java, C). But with JavaScript, you have to add external tools (Typescript, Eslint) to get such feedback, so in your reality, it’s one of the layers of testing.

4 — There is one aspect that is left out in this pyramid: As you move up the pyramid, the confidence coefficient of each form of testing increases.

![image6](https://miro.medium.com/max/1400/1*2WNZBbX_68J-EkIy4nx8ZQ.png)

The confidence coefficient means, the higher you go up the testing pyramid, the closer you are getting to your tests resembling the way that your software is used. And so the confidence that you get from those also goes up.

> For example, if you have a checkout feature, testing the entire process in the same way that a real user would interact with, allows you to cover and ensure that all the sub-elements used work together.

So while E2E tests may be slower and more expensive than unit tests, they bring you much more confidence that your application is working as intended.
On the opposite, Units tests are faster and cheaper, but by testing them you might find yourselves:

- Testing pieces in isolation (which doesn’t give you confidence that they work properly together)
- Testing implementations details
- Mocking a lot

which are many factors that take you away from the principle of “Tests your application in the exact same way that your user would interact with” and so trade away confidence.

#### Testing trophy

![image7](https://miro.medium.com/max/1400/1*NkeRL80U-fE3N5YeuIeSHA.png)

With the testing trophy, we keep the same testing stack: **E2E**, **Integrations**, and **Unit**; but you changed the ratio between the different shapes. we also add the **Static** layer to represent the reality of JavaScript.

**E2E tests** are the type of automated testing that gives the most confidence that your software works well as intended. Maybe in the future our E2E tools will just get so much better that you will just focus 100% on it, but today they can still be expensive to write and run. So you are going to focus only on some high-level critical tests which can require the interactions of multiple systems (Front-end, back-ends, …) and represent production data. In E2E you are generally going to assume the happy path and especially avoid over-testing.

**Integration tests** are the widest layer of the trophy because it’s where you should focus most of your effort. They strike a great balance on the trade-offs between confidence and speed/expense to write and run your tests. They test some happy paths and unhappy paths. By testing that several parts of your software work well together as intended, you will be able to cover a lot of use cases in the same way that the end-user would interact with it; And you’ll find that you often don’t need to bother testing each smaller piece in isolation.

**Unit tests** are the smallest section of the trophy. It’s all about focusing your effort on testing little edge cases, or typically pure functions which have a lot of complex logic. Here you are not testing the business cases (the cases that the end-user will have). The users of your units are typically the other developers which would call your function from a developer’s perspective.

**Static tests** should be applied everywhere in the application because they give you a lot of information without even needing to run your application.

> The ratio between each shapes is not 100% accurate, most of the time you would like to have more E2E than Unit tests.

---

**Resources:**

- [Kent C. Dodds — How to know what to test?](https://youtu.be/ahrvE062Kv4)
- [Kent C. Dodds — Why you should double down on integration tests?](https://www.software-engineering-unlocked.com/double-down-integration-tests-kent-dodds/)

---

## III) 결론

![image7](https://miro.medium.com/max/1194/1*vqODTN3LTNPhhgcAX9kJcA.png)

This tweet from Guillermo Rauch (CEO and founder of Vercel) is a perfect summary of that testing philosophy :

- Write tests: They give you CONFIDENCE that your software work as intended
- Not too many: Do not mandate 100% code coverage. You should think less about the code you are testing and more about the use cases that the code supports.
- Mostly integration: They are the best balance on the trade-offs between confidence and speed/expense to write and run your tests.

It is also important to mention that Manual testing will surely still have a place for decades among the testing strategy. There will always be some use cases that weren’t anticipated and tested by the developers, and a real human eye can help on that part. But as you write automated tests, confidence increases and your need for manual testing will decrease. There are lots of benefits with manual testing but many problems such as the amount of time and resources needed.

It’s again all about trade-offs, what is critical for the end-user and so where you want to put your effort. You want to be confident that when you deploy your changes, your code satisfies the business requirements, and you provide an awesome experience to your Users. And you should use a mix of the different testing strategies to accomplish that goal.

읽어주셔서 감사합니다.

---

**Resources:**

- [Kent C. Dodds — Write tests. Not too many. Mostly integration.](https://kentcdodds.com/blog/write-tests)
- [Kent C. Dodds — Confident React](https://youtu.be/eg_TFYF_cKM)
- [Adrià Fontcuberta — The Pragmatic Front End Tester](https://youtu.be/pfJdNiDOJ-A)
